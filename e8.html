<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E8 Lie Group: The Ultimate Mathematical Chaos</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #e1bee7;
            overflow: hidden;
            font-family: 'Orbitron', 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            background: radial-gradient(ellipse at center, #001122 0%, #000 70%);
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 13px;
            line-height: 1.6;
            max-width: 350px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 2px solid #00acc1;
            border-radius: 8px;
            box-shadow: 0 0 25px rgba(0, 172, 193, 0.6), inset 0 0 10px rgba(0, 172, 193, 0.1);
            color: #b2ebf2;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .info:hover {
            box-shadow: 0 0 35px rgba(0, 172, 193, 0.8), inset 0 0 15px rgba(0, 172, 193, 0.2);
        }

        .info h3 {
            margin: 0 0 10px 0;
            color: #26c6da;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(38, 198, 218, 0.5);
        }

        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border: 2px solid #0277bd;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(2, 119, 189, 0.5);
            backdrop-filter: blur(5px);
        }

        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border: 1px solid #0288d1;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #81d4fa;
        }

        .highlight {
            color: #ff6090;
            font-weight: bold;
        }

        .math-highlight {
            color: #64ffda;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>üåå E8.ULTIMATE.EXE</h3>
        <p>The <span class="highlight">E8 Lie Group</span> root system - one of the most exceptional mathematical structures in existence.</p>
        <p>This is <span class="math-highlight">248-dimensional symmetry</span> projected down to your pathetic 3D reality. Each point represents a root vector in 8D space.</p>
        <p><strong>E8 Facts:</strong><br>
        ‚Ä¢ <span class="math-highlight">240 root vectors</span> in 8D<br>
        ‚Ä¢ <span class="math-highlight">248-dimensional</span> Lie algebra<br>
        ‚Ä¢ Connected to string theory & physics<br>
        ‚Ä¢ Absolutely mind-breaking beauty</p>
        <p>Rotating through <span class="highlight">8 dimensions</span> simultaneously. Your brain is not equipped for this.</p>
    </div>

    <div class="controls">
        <p><strong>REALITY CONTROLS:</strong></p>
        <p>üñ±Ô∏è Mouse: 3D Perspective</p>
        <p>üîç Scroll: Zoom In/Out</p>
        <p>‚è∏Ô∏è Space: Pause/Resume</p>
        <p>üîÑ R: Reset All</p>
        <p>üé≤ C: Chaos Mode</p>
        <p>üí´ V: Visual Mode</p>
        <p>üåü E: Root Emphasis</p>
        <p>üëª H: Hide/Show UI</p>
        <p>üåà G: Color Mode</p>
    </div>

    <div class="stats">
        <div id="fps">FPS: --</div>
        <div id="mode">Mode: Standard</div>
        <div id="zoom">Zoom: 1.00x</div>
        <div id="roots">Roots: 240</div>
        <div id="colorMode">Color: Categorical</div>
    </div>

    <canvas id="e8Canvas"></canvas>

    <script>
        // Global variables
        let uiVisible = true;

        const canvas = document.getElementById('e8Canvas');
        const ctx = canvas.getContext('2d');
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // Performance tracking
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        });

        // Generate E8 root system (correctly)
        function generateE8Roots() {
            const roots = new Set();

            // Type 1: Permutations of (¬±1,¬±1,0,0,0,0,0,0) - 112 roots
            // This is the D8 root system
            const signs = [-1, 1];
            for (let i = 0; i < 8; i++) {
                for (let j = i + 1; j < 8; j++) {
                    for (const s1 of signs) {
                        for (const s2 of signs) {
                            const root = new Array(8).fill(0);
                            root[i] = s1;
                            root[j] = s2;
                            roots.add(JSON.stringify(root));
                        }
                    }
                }
            }
            
            // Type 2: (¬±1/2, ¬±1/2, ¬±1/2, ¬±1/2, ¬±1/2, ¬±1/2, ¬±1/2, ¬±1/2) with an even number of minus signs - 128 roots
            for (let i = 0; i < 256; i++) {
                let minusCount = 0;
                const root = [];
                for (let j = 0; j < 8; j++) {
                    const sign = ((i >> j) & 1) === 0 ? 0.5 : -0.5;
                    if (sign === -0.5) minusCount++;
                    root.push(sign);
                }
                if (minusCount % 2 === 0) {
                    roots.add(JSON.stringify(root.map(x => x*2))); // Scale up by 2 to make lengths consistent
                }
            }

            return Array.from(roots).map(str => JSON.parse(str));
        }

        const e8Roots = generateE8Roots();
        document.getElementById('roots').textContent = `Roots: ${e8Roots.length}`;

        // Create connections between nearby roots (for visualization)
        const connections = [];
        const threshold = 2.05; // A threshold that connects roots of the same length

        for (let i = 0; i < e8Roots.length; i++) {
            for (let j = i + 1; j < e8Roots.length; j++) {
                const dist = Math.sqrt(
                    e8Roots[i].reduce((sum, val, idx) => 
                        sum + Math.pow(val - e8Roots[j][idx], 2), 0)
                );
                if (dist < threshold) {
                    connections.push([i, j]);
                }
            }
        }

        // Color schemes
        const rootColors = {
            d8: '#00acc1',
            e8_d8: '#ff4081',
            dimColors: ['#ff4081', '#ffc107', '#00acc1', '#4caf50', '#ff6090', '#ab47bc', '#e1bee7', '#f3e5f5']
        };

        const colorModeNames = ['Categorical', 'Dimensional', 'Velocity'];
        let colorMode = 0; // 0: Categorical, 1: Dimensional, 2: Velocity

        function getColorForRoot(root, index, velocity) {
            switch (colorMode) {
                case 0: // Categorical
                    return root.includes(0) ? rootColors.d8 : rootColors.e8_d8;
                case 1: // Dimensional
                    let r = 0, g = 0, b = 0;
                    const nonZeroCount = root.filter(x => x !== 0).length;
                    
                    if (nonZeroCount === 0) return '#ffffff'; // Should not happen for E8 roots
                    
                    root.forEach((val, i) => {
                        if (val !== 0) {
                            const hex = rootColors.dimColors[i];
                            r += parseInt(hex.substring(1, 3), 16) / nonZeroCount;
                            g += parseInt(hex.substring(3, 5), 16) / nonZeroCount;
                            b += parseInt(hex.substring(5, 7), 16) / nonZeroCount;
                        }
                    });
                    
                    return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;

                case 2: // Velocity
                    const speed = Math.sqrt(velocity[0] * velocity[0] + velocity[1] * velocity[1] + velocity[2] * velocity[2]);
                    const hue = Math.floor((speed * 200) % 360);
                    const saturation = 100;
                    const lightness = 50 + velocity[2] * 20; // Lighter for nodes coming towards you
                    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }
        }

        let rotation8D = {
            xy: 0, xz: 0, xw: 0, xu: 0, xv: 0, xs: 0, xt: 0,
            yz: 0, yw: 0, yu: 0, yv: 0, ys: 0, yt: 0,
            zw: 0, zu: 0, zv: 0, zs: 0, zt: 0,
            wu: 0, wv: 0, ws: 0, wt: 0,
            uv: 0, us: 0, ut: 0,
            vs: 0, vt: 0,
            st: 0
        };

        let rotation3D = { x: 0, y: 0 };
        let mouseX = 0, mouseY = 0;
        let isPaused = false;
        let chaosMode = false;
        let visualMode = 0;
        let rootEmphasis = false;
        let zoomLevel = 1.0;
        let previous3DPositions = [];

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - width / 2) / (width / 2);
            mouseY = (e.clientY - height / 2) / (height / 2);
            rotation3D.y = mouseX * Math.PI * 0.8;
            rotation3D.x = mouseY * Math.PI * 0.8;
        });

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'Space':
                    e.preventDefault();
                    isPaused = !isPaused;
                    break;
                case 'KeyR':
                    rotation8D = {
                        xy: 0, xz: 0, xw: 0, xu: 0, xv: 0, xs: 0, xt: 0,
                        yz: 0, yw: 0, yu: 0, yv: 0, ys: 0, yt: 0,
                        zw: 0, zu: 0, zv: 0, zs: 0, zt: 0,
                        wu: 0, wv: 0, ws: 0, wt: 0,
                        uv: 0, us: 0, ut: 0,
                        vs: 0, vt: 0,
                        st: 0
                    };
                    rotation3D = { x: 0, y: 0 };
                    zoomLevel = 1.0;
                    if(uiVisible) document.getElementById('zoom').textContent = `Zoom: ${zoomLevel.toFixed(2)}x`;
                    break;
                case 'KeyC':
                    chaosMode = !chaosMode;
                    if(uiVisible) document.getElementById('mode').textContent = `Mode: ${chaosMode ? 'CHAOS' : 'Standard'}`;
                    break;
                case 'KeyV':
                    visualMode = (visualMode + 1) % 3;
                    const modes = ['Standard', 'Lines', 'Minimal'];
                    if(uiVisible) document.getElementById('mode').textContent = `Mode: ${modes[visualMode]}`;
                    break;
                case 'KeyE':
                    rootEmphasis = !rootEmphasis;
                    if(uiVisible) document.getElementById('mode').textContent = `Emphasis: ${rootEmphasis ? 'ON' : 'OFF'}`;
                    break;
                case 'KeyH':
                    uiVisible = !uiVisible;
                    const info = document.querySelector('.info');
                    const controls = document.querySelector('.controls');
                    const stats = document.querySelector('.stats');
                    info.style.opacity = uiVisible ? '1' : '0';
                    controls.style.opacity = uiVisible ? '1' : '0';
                    stats.style.opacity = uiVisible ? '1' : '0';
                    break;
                case 'KeyG':
                    colorMode = (colorMode + 1) % 3;
                    document.getElementById('colorMode').textContent = `Color: ${colorModeNames[colorMode]}`;
                    break;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            const zoomFactor = 1 - (e.deltaY * zoomSensitivity);
            zoomLevel *= zoomFactor;
            zoomLevel = Math.max(0.1, Math.min(8.0, zoomLevel));
            if(uiVisible) document.getElementById('zoom').textContent = `Zoom: ${zoomLevel.toFixed(2)}x`;
        }, { passive: false });

        function rotate8D(vector, rotations) {
            let [x, y, z, w, u, v, s, t] = vector;
            let cos, sin;
            cos = Math.cos(rotations.xy); sin = Math.sin(rotations.xy); [x, y] = [x * cos - y * sin, x * sin + y * cos];
            cos = Math.cos(rotations.zw); sin = Math.sin(rotations.zw); [z, w] = [z * cos - w * sin, z * sin + w * cos];
            cos = Math.cos(rotations.uv); sin = Math.sin(rotations.uv); [u, v] = [u * cos - v * sin, u * sin + v * cos];
            cos = Math.cos(rotations.st); sin = Math.sin(rotations.st); [s, t] = [s * cos - t * sin, s * sin + t * cos];
            cos = Math.cos(rotations.xw); sin = Math.sin(rotations.xw); [x, w] = [x * cos - w * sin, x * sin + w * cos];
            cos = Math.cos(rotations.yu); sin = Math.sin(rotations.yu); [y, u] = [y * cos - u * sin, y * sin + u * cos];
            cos = Math.cos(rotations.zv); sin = Math.sin(rotations.zv); [z, v] = [z * cos - v * sin, z * sin + v * cos];
            return [x, y, z, w, u, v, s, t];
        }

        function rotate3D(vertex, rotations) {
            let [x, y, z] = vertex;
            let cos = Math.cos(rotations.y), sin = Math.sin(rotations.y); [x, z] = [x * cos - z * sin, x * sin + z * cos];
            cos = Math.cos(rotations.x); sin = Math.sin(rotations.x); [y, z] = [y * cos - z * sin, y * sin + z * cos];
            return [x, y, z];
        }

        function animate(currentTime) {
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                if (uiVisible) {
                    document.getElementById('fps').textContent = `FPS: ${fps}`;
                }
                frameCount = 0;
                lastTime = currentTime;
            }

            ctx.clearRect(0, 0, width, height);
            
            if (!isPaused) {
                const baseSpeed = 0.005;
                const speed = chaosMode ? baseSpeed * (1.5 + Math.sin(currentTime * 0.0005)) : baseSpeed;
                rotation8D.xy += speed * 1.0; rotation8D.zw += speed * 0.8; rotation8D.uv += speed * 0.6;
                rotation8D.st += speed * 0.4; rotation8D.xw += speed * 0.7; rotation8D.yu += speed * 0.5;
                rotation8D.zv += speed * 0.3;
            }

            const rotatedRoots = e8Roots.map(root => rotate8D(root, rotation8D));
            const projected3D = rotatedRoots.map(root => [root[0], root[1], root[2]]);
            const final3D = projected3D.map(vertex => rotate3D(vertex, rotation3D));

            // Calculate velocities for Velocity Mode
            const velocities = [];
            if (previous3DPositions.length > 0) {
                for (let i = 0; i < final3D.length; i++) {
                    const vel = [
                        final3D[i][0] - previous3DPositions[i][0],
                        final3D[i][1] - previous3DPositions[i][1],
                        final3D[i][2] - previous3DPositions[i][2]
                    ];
                    velocities.push(vel);
                }
            }
            previous3DPositions = final3D.map(v => [...v]);

            const projected2D = final3D.map((vertex, index) => {
                const baseScale = visualMode === 2 ? 150 : 200;
                const scale = baseScale * zoomLevel;
                const perspective = 4;
                const z = vertex[2] + perspective;
                const factor = perspective / Math.max(z, 0.1);
                return [
                    (vertex[0] * factor * scale) + width / 2,
                    (vertex[1] * factor * scale) + height / 2,
                    z,
                    index
                ];
            });

            if (visualMode !== 2 && connections.length > 0) {
                const maxConnections = chaosMode ? connections.length : Math.min(500, connections.length);
                const edgesToDraw = [];
                for (let i = 0; i < maxConnections; i++) {
                    const [idx1, idx2] = connections[i];
                    if (idx1 < projected2D.length && idx2 < projected2D.length) {
                        const p1 = projected2D[idx1];
                        const p2 = projected2D[idx2];
                        const avgZ = (p1[2] + p2[2]) / 2;
                        edgesToDraw.push({ p1, p2, avgZ });
                    }
                }
                edgesToDraw.sort((a, b) => b.avgZ - a.avgZ);
                ctx.lineWidth = visualMode === 1 ? 1 : 0.5;
                edgesToDraw.forEach(edge => {
                    const { p1, p2 } = edge;
                    ctx.strokeStyle = '#00acc1';
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.moveTo(p1[0], p1[1]);
                    ctx.lineTo(p2[0], p2[1]);
                    ctx.stroke();
                });
            }

            projected2D.forEach((point, index) => {
                const velocity = velocities[index] || [0, 0, 0];
                const color = getColorForRoot(e8Roots[index], index, velocity);
                
                let baseRadius = 3;
                if (visualMode === 1) baseRadius = 4;
                if (visualMode === 2) baseRadius = 2;
                if (rootEmphasis) baseRadius = 4;
                
                const radius = baseRadius * (0.8 + 0.4 * Math.sin(currentTime * 0.001 + index * 0.1));
                const finalRadius = radius * (1 + point[2] * 0.2); // Tamed scaling
                if (finalRadius < 0) finalRadius = 0;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(point[0], point[1], finalRadius, 0, Math.PI * 2);
                ctx.fill();

                if (visualMode === 1 && rootEmphasis) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            requestAnimationFrame(animate);
        }

        animate(0);
    </script>
</body>
</html>
